#!/bin/bash

# Bootstrap or rotate the infrastructure maintenance engine
# Creates a fresh conda environment containing deployment tools

set -euo pipefail

# Default values
OFFLINE=""
VERBOSE=""
YES=""
DRY_RUN=""
FORCE=""
TARGET_DIR=""

main() {
    parse_args "$@"

    log_info "Starting bootstrap-engine"
    log_debug "Arguments: TARGET_DIR=$TARGET_DIR, OFFLINE=$OFFLINE, VERBOSE=$VERBOSE, YES=$YES"

    check_disk_space "$TARGET_DIR"
    determine_project_root
    setup_environment
    setup_micromamba
    select_engine_directory
    create_engine_environment
    update_engine_symlink

    log_info "Engine bootstrap complete"
    log_info "Engine location: $ENGINE_PATH"
    log_info "Engine symlink: $ENGINE_HOME/engine"
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --offline)
                OFFLINE="--offline"
                shift
                ;;
            -v|--verbose)
                VERBOSE="1"
                shift
                ;;
            -y|--yes)
                YES="-y"
                shift
                ;;
            -n|--dry-run)
                DRY_RUN="y"
                shift
                ;;
            --force)
                FORCE="y"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                if [[ -n "$TARGET_DIR" ]]; then
                    die "Too many arguments"
                fi
                TARGET_DIR="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$TARGET_DIR" ]]; then
        die "TARGET_DIR argument is required"
    fi
}

determine_project_root() {
    # Get the directory containing this script, then go up one level
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
    log_debug "PROJECT_ROOT=$PROJECT_ROOT"
}

setup_environment() {
    # Set ENGINE_HOME to cache/ inside project root
    export ENGINE_HOME="$TARGET_DIR/engine_home"
    log_debug "ENGINE_HOME=$ENGINE_HOME"

    # Set conda package cache directory
    export CONDA_PKGS_DIRS="$TARGET_DIR/conda_package_cache"
    log_debug "CONDA_PKGS_DIRS=$CONDA_PKGS_DIRS"

    # Create necessary directories
    if [[ -n "$DRY_RUN" ]]; then
        log_info "[DRY RUN] Would create directories: $ENGINE_HOME, $CONDA_PKGS_DIRS"
    else
        mkdir -p "$ENGINE_HOME"
        mkdir -p "$CONDA_PKGS_DIRS"
    fi
}

check_disk_space() {
    local path="$1"
    local minimum_gb=5

    # Get available space in GB using df
    # Use the directory if it exists, otherwise use parent directory
    local check_path="$path"
    if [[ ! -d "$check_path" ]]; then
        check_path="$(dirname "$path")"
    fi

    # Get available space in KB, convert to GB
    local available_kb
    available_kb=$(df -k "$check_path" | awk 'NR==2 {print $4}')
    local available_gb=$((available_kb / 1024 / 1024))

    log_debug "Disk space check: ${available_gb}GB available at $check_path"

    if [[ $available_gb -lt $minimum_gb ]]; then
        log_error "Insufficient disk space for bootstrap"
        log_error "Available: ${available_gb}GB"
        log_error "Required: ${minimum_gb}GB minimum"
        log_error ""
        if [[ -z "$FORCE" ]]; then
            die "Bootstrap requires at least ${minimum_gb}GB of free space. Use --force to override." 4
        else
            log_error "WARNING: Proceeding anyway due to --force flag"
            log_error ""
        fi
    fi
}

check_required_binaries() {
    # Check for binaries required by fetch-micromamba
    local missing=()

    if ! command -v /usr/bin/curl &> /dev/null; then
        missing+=("curl")
    fi

    if ! command -v /usr/bin/tar &> /dev/null; then
        missing+=("tar")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Required binaries not found: ${missing[*]}"
        log_error ""
        for binary in "${missing[@]}"; do
            case "$binary" in
                curl)
                    log_error "Install curl with:"
                    log_error "  - apt-get install curl (Debian/Ubuntu)"
                    log_error "  - yum install curl (RHEL/CentOS)"
                    log_error "  - brew install curl (macOS)"
                    ;;
                tar)
                    log_error "Install tar with:"
                    log_error "  - Usually pre-installed on Unix systems"
                    log_error "  - apt-get install tar (Debian/Ubuntu)"
                    log_error "  - yum install tar (RHEL/CentOS)"
                    ;;
            esac
            log_error ""
        done
        die "Missing required binaries for bootstrap" 2
    fi
}

setup_micromamba() {
    # Check for required binaries before fetching micromamba
    check_required_binaries

    # Check if micromamba already exists
    MAMBA="$ENGINE_HOME/micromamba"
    if [[ ! -x "$MAMBA" ]]; then
        log_info "Setting up micromamba..."
        if [[ -n "$DRY_RUN" ]]; then
            log_info "[DRY RUN] Would fetch micromamba to: $ENGINE_HOME"
        else
            "$SCRIPT_DIR/fetch-micromamba" "$ENGINE_HOME"
            if [[ ! -x "$MAMBA" ]]; then
                die "Failed to setup micromamba at $MAMBA" 2
            fi
        fi
    fi
    log_debug "MAMBA=$MAMBA"
}

# Pure function for determining next engine based on current target
# This would normally be extracted to a separate file, but bash doesn't have
# a good module system, so we document it as a pure function here.
determine_next_engine() {
    local current_target="$1"
    # Simple blue/green rotation: if engine_a is current, use engine_b, otherwise use engine_a
    if [[ "$current_target" == "engine_a" ]]; then
        echo "engine_b"
    else
        echo "engine_a"
    fi
}

select_engine_directory() {
    local engine_a="$ENGINE_HOME/engine_a"
    local engine_b="$ENGINE_HOME/engine_b"

    # Simple blue/green rotation: if engine_a exists and is linked, use engine_b, otherwise use engine_a
    local current_link="$ENGINE_HOME/engine"
    if [[ -L "$current_link" ]]; then
        local current_target
        current_target="$(readlink "$current_link")"
        local next_engine
        next_engine="$(determine_next_engine "$current_target")"
        if [[ "$next_engine" == "engine_b" ]]; then
            ENGINE_PATH="$engine_b"
        else
            ENGINE_PATH="$engine_a"
        fi
    else
        ENGINE_PATH="$engine_a"
    fi

    log_debug "Selected engine directory: $ENGINE_PATH"
}

create_engine_environment() {
    local engine_yaml="$PROJECT_ROOT/resources/defs/special/engine.yaml"

    if [[ ! -f "$engine_yaml" ]]; then
        die "Engine definition not found: $engine_yaml" 3
    fi

    # Remove existing engine directory if it exists
    if [[ -d "$ENGINE_PATH" ]]; then
        log_info "Removing existing engine directory: $ENGINE_PATH"
        if [[ -n "$DRY_RUN" ]]; then
            log_info "[DRY RUN] Would remove: $ENGINE_PATH"
        else
            rm -rf "$ENGINE_PATH"
        fi
    fi

    # Build mamba command
    local mamba_cmd=("$MAMBA" "env" "create" "-p" "$ENGINE_PATH" "-f" "$engine_yaml")
    if [[ -n "$OFFLINE" ]]; then
        mamba_cmd+=("$OFFLINE")
    fi
    if [[ -n "$YES" ]]; then
        mamba_cmd+=("$YES")
    fi

    log_info "Creating engine environment..."
    log_debug "Command: ${mamba_cmd[*]}"

    if [[ -n "$DRY_RUN" ]]; then
        log_info "[DRY RUN] Would run: ${mamba_cmd[*]}"
    else
        # Run command in sanitized environment
        "$SCRIPT_DIR/sanitize-command" \
            CONDA_PKGS_DIRS="$CONDA_PKGS_DIRS" \
            "${mamba_cmd[@]}"
    fi
}

update_engine_symlink() {
    local engine_link="$ENGINE_HOME/engine"
    local engine_name
    engine_name="$(basename "$ENGINE_PATH")"

    # Remove existing symlink if present
    if [[ -L "$engine_link" ]]; then
        log_debug "Removing existing engine symlink"
        if [[ -n "$DRY_RUN" ]]; then
            log_info "[DRY RUN] Would remove symlink: $engine_link"
        else
            rm "$engine_link"
        fi
    elif [[ -e "$engine_link" ]]; then
        die "Engine path exists but is not a symlink: $engine_link" 3
    fi

    # Create new symlink
    log_info "Creating engine symlink: $engine_link -> $engine_name"
    if [[ -n "$DRY_RUN" ]]; then
        log_info "[DRY RUN] Would create symlink: $engine_link -> $engine_name"
    else
        cd "$ENGINE_HOME"
        ln -s "$engine_name" engine
    fi
}

usage() {
    cat << EOF
Usage: $(basename "${BASH_SOURCE[0]}") [OPTIONS] TARGET_DIR

Bootstrap or rotate the infrastructure maintenance engine.

Arguments:
    TARGET_DIR    Parent directory of engine_home

Options:
    --offline      Run conda create with --offline option
    -v, --verbose  Enable verbose logging
    -y, --yes      Pass -y flag to mamba command (assume yes for prompts)
    -n, --dry-run  Show what would be done without making changes
    --force        Bypass disk space checks and other safety checks
    -h, --help     Show this help message

Environment variables set automatically:
    ENGINE_HOME      Set to TARGET_DIR/engine_home
    CONDA_PKGS_DIRS  Set to TARGET_DIR/conda_package_cache

Exit codes:
  0   Success
  1   General error (usage error, missing TARGET_DIR, missing dependency)
  2   Missing dependency (failed to setup micromamba)
  3   Invalid input (missing engine.yaml, invalid path)
  4   Operation failed (command execution failure)
EOF
}

die() {
    log_error "$1"
    exit "${2:-1}"
}

log_info() {
    echo "INFO: $*" >&2
}

log_debug() {
    if [[ -n "$VERBOSE" ]]; then
        echo "DEBUG: $*" >&2
    fi
}

log_error() {
    echo "ERROR: $*" >&2
}

main "$@"
